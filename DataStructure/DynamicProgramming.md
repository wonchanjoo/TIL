# 동적 계획법(Dynamic Programming, DP)

: 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법

</br>

### ✔️ 원리와 구현 방식

1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결과값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다. = **memoization 기법**
4. 동적 계획법은 **top-down** 방식과 **bottom-up** 방식으로 구현할 수 있다.

</br>

## 피보나치 수열

> D[N] = D[N - 1] + D[N - 2]

1. 동적 계획법으로 풀 수 있는지 확인하기

   - n번째 피보나치 수열은 n-1번째 피보나치 수열과 n-2번째 피보나치 수열의 합이다. 즉, n번째 피보나치 수열을 구하는 문제는 n-1번째 피보나치 수열과 n-2번째 피보나치 수열을 구하는 작은 문제로 나눌 수 있고, 수열의 합은 항상 같기 때문에 동적 계획법으로 풀 수 있다.

2. 점화식 세우기

   - 점화식 세울 때는 논리적으로 전체 문제를 나누고, 전체 문제와 부분 문제 간의 인과 관계를 파악하는 훈련이 필요하다.
   - 피보나치 수열의 점화식은 D[i] = D[i - 1] + D[i - 2]이다.

3. memoization 원리 이해하기

   - **memoization**: 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고 다음에 같은 문제가 나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것

4. top-down 구현 방식 이해하기

   - 위에서부터 문제를 파악해 내려오는 방법이다. 주로 재귀 함수 형태로 코드를 구현한다. 코드의 가독성이 좋고 이해하기가 편하다는 장점이 있다.

   ```java
   int fibo(int n) {
     	if(D[n] != -1) // 기존에 계산한 적이 있는 경우
         	return D[n];
     	return D[n] = fibo(n - 2) + fibo(n - 1);
   }
   ```

5. bottom-up 구현 방식 이해하기

   - 가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해 나가는 방법이다. 주로 반복문의 형태로 구현한다.

   ```java
   for(int i = 2; i <= n; i++) {
     	D[i] = D[i - 1] + D[i - 2];
   }
   ```

   