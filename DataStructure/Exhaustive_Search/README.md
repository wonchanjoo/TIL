# 완전탐색

- 모든 경우의 수를 시도하여 정답을 찾는 방법
- Brute Force
- 상대적으로 간단한 방법이지만 경우의 수가 많아지면 시간이 오래걸린다.

</br>

## 1️⃣ 단순 Brute-Force

- 특별한 기법 없이 for문과 if문으로 모든 경우의 수를 체크하여 답을 구한다.
- 이 방법으로 해결할 수 있는 문제가 많지 않다.
- 문제 일부분을 해결할 때 사용

</br>

## 2️⃣ 비트마스트(Bitmask)

- 각 원소를 두 가지 상태로 분류할 수 있을 때 사용
  - ex) 모든 경우의 수에서 각각의 원소가 포함되거나 포함되지 않는 경우 - 원소 n개인 집합의 부분집합 구하기

</br>

## 3️⃣ 재귀함수

```java
// 1 ~ 100 숫자 중, 5개를 선택하는 경우
public class Main {
  static int lim = 100; // 1~100까지의 제한
  static int n = 5; // 5개만 고른다
  
  public static void main(String[] args) {
    int[] chosen = new int[n]; // 선택된 숫자가 저장되는 배열
    
    solve(chosen, 0, 0);
  }
  
  // chosen: 선택된 숫자가 저장되는 배열
  // curr: 현재 숫자를 선택하는 index
  // cnt: 몇 개의 숫자가 선택되었는지 확인
  private static void solve(int[] chosen, int curr, int cnt) {
    if(cnt == n) {
      return;
    }
    
    // 반복문을 통해 숫자를 계속 선택
    for(int i = curr + 1; i <= lim; i++) {
      // 현재 선택된 숫자를 저장
      chosen[cnt] = i;
      // 다음 숫자를 선택하기 위해 재귀 호출
      solve(chosen, curr, cnt + 1);
    }
  }
}
```

1. 재귀를 탈출하기위한 탈출 조건이 필요하다.
2. 현재 함수 상태를 저장하는 Parameter가 필요하다.
3. return문 신경쓰기!
   - 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우가 있을 수 있다. 

</br>

## 4️⃣ 순열

- 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법
  - 수열 {1, 2, 3}이 있을 때, 이것을 {1, 2, 3}으로 보는 순서와 {3, 2, 1}로 보는 순서가 차이가 있음이 중요한 경우
  - 같은 데이터가 입력된 수열이지만 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전/다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.
- N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순 (반대로 최초 순열이면 i+1부터 N이 오름차순)
  - {1, 3, 2}는 0번째 숫자가 1일 때의 최종 순열이다. 왜냐하면 3 2는 내림차순이기 때문이다.

</br>

###### 순열을 구현하는 방법

현재 순열을 구성하는 배열을 A라 하고 i, j는 그 배열의 index 값을 의미한다고 하자. 예를 들어 A={7, 2, 3, 6, 5, 4, 1}이고 i,j는 각각의 index 값이다.

아래에서는 현재의 다음 순열을 구하는 로직을 기반으로 설명한다.

1. **A[i - 1] <= A[i]** 를 만족하는 i 중 가장 큰 값을 찾는다. (혹은 뒤에서부터 찾는 경우 **A[i - 1] >= A[i]**  중 가장 작은 i를 찾는다.

   -> 현재 i 값을 기준으로 이후는 모두 내림차 순으로 되는 경우를 찾는 것이다. 현재 기준 최종 순열을 찾는다.

   -> A 배열을 보면 A[i - 1] <= A[i] 가 되는 가장 큰 i는 6인 3번째이다. 즉, i = 3이 된다.

2. j >= i 중, A[j] > A[i - 1]을 만족하는 가장 큰 j의 값을 찾는다.

   -> 현재가 최종 순열 상태이므로 i - 1 번째 숫자를 변경하여 최초 순열을 찾아야 한다.

   -> A 배열을 기준으로 i - 1번재 숫자는 3으로 3보다 큰 경우는 6, 5, 4이나 그 중 j 값이 가장 큰 경우는 4이다.

3. A[i - 1]과 A[j]를 Swap 한다.

   -> i - 1인 2번째 숫자 2과 j인 5번째 숫자 4를 변경한다. A 배열은 다음과 같이 변경된다.

   A = {7, 2, 4, 6, 5, 3, 1}

4. i 이후의 순열을 모두 뒤집는다.

   -> 최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다. A 배열은 다음과 같이 변경된다.

   A = {7, 2, 4, 1, 3, 5, 6}

</br>

https://hongjw1938.tistory.com/78